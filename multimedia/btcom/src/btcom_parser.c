#include "../../../ax32_platform_demo/application.h"
#include "../inc/btcom.h"
#include "../inc/btcom_inner.h"


#if 0
// 全局数据
static CMD_PARSER_T   cmdData[] = {
	{BTCOM_GET_STATE,         NULL}, // = 0xA3,
	{BTCOM_SET_QUALITY,       NULL}, // = 0xA4,
	{BTCOM_SEND_BITMAP,       NULL}, // = 0xA5,
	{BTCOM_FEED,              NULL}, // = 0xA1,
	{BTCOM_SEND_LINE_DATA,    NULL}, // = 0xA2,
	{BTCOM_GET_DEVINFO,       NULL}, // = 0xA8,
	{BTCOM_FLOW_CONTROL,      NULL}, // = 0xAE,
	{BTCOM_SET_ENERGE25,      NULL}, // = 0xAF,
	{BTCOM_SEND_LINE_DATA_ZIP,NULL}, // = 0xBF,
	{BTCOM_SET_PRINT_SPEED,   NULL}, // = 0xBE,
	{BTCOM_SET_MOTOR_STEP_TIME,NULL},// = 0xBD,
	{BTCOM_PRINT_IGNORE,      NULL}, // = 0xBC,
	{BTCOM_SET_LED_SCREEN,    NULL}, // = 0xA6,
	{BTCOM_SET_FLAG_BIT,      NULL}, // = 0xBC,
	{BTCOM_WRITE_DEVICE_ID,   NULL}, // = 0xBB,
	{BTCOM_SET_DENSITY,       NULL}, // = 0xF2,
};

/**
 * 解析器初始化
 *
 */
void btcomParserInit(void)
{
	int i, j;
	u8 min_cmd;

	for (i = 0; i < sizeof(cmdData)/sizeof(cmdData[0]) - 1; i++) {
		min_cmd = i;
		for (j = i + 1; j < sizeof(cmdData)/sizeof(cmdData[0]); j++) {
			if (cmdData[j].cmd < cmdData[min_cmd].cmd) {
				min_cmd = j;
			}
		}
		if (min_cmd != i) {
			CMD_PARSER_T tmp;
			tmp.cmd = cmdData[min_cmd].cmd;
			tmp.fnParser = cmdData[min_cmd].fnParser;
			cmdData[min_cmd].cmd = cmdData[i].cmd;
			cmdData[min_cmd].fnParser = cmdData[i].fnParser;
			cmdData[i].cmd = tmp.cmd;
			cmdData[i].fnParser = tmp.fnParser;
		}
	}
}

/**
 * 判断是否支持给定命令
 *
 * cmd - 给定命令
 *
 * 返回:true - 支持；false - 不支持
 *
 */
bool btcomCmdSupport(u8 cmd)
{
	int begin, end, mid;
	bool ret = false;

	begin = 0;
	end = sizeof(cmdData)/sizeof(cmdData[0]) - 1;
	while (begin <= end) {
		mid = (begin + end)>>1;
		if (cmdData[mid].cmd == cmd) {
			ret = true;
			break;
		} else if (cmdData[mid].cmd < cmd) {
			begin = mid + 1;
		} else {
			end = mid - 1;
		}
	}

	return ret;
}
#else
#if 0
// 全局数据
static u8   cmdData[] = {
	BTCOM_GET_STATE,           // = 0xA3,
	BTCOM_SET_QUALITY,         // = 0xA4,
	BTCOM_SEND_BITMAP,         // = 0xA5,
	BTCOM_FEED,                // = 0xA1,
	BTCOM_SEND_LINE_DATA,      // = 0xA2,
	BTCOM_GET_DEVINFO,         // = 0xA8,
	BTCOM_FLOW_CONTROL,        // = 0xAE,
	BTCOM_SET_ENERGE25,        // = 0xAF,
	BTCOM_SEND_LINE_DATA_ZIP,  // = 0xBF,
	BTCOM_SET_PRINT_SPEED,     // = 0xBE,
	BTCOM_SET_MOTOR_STEP_TIME, // = 0xBD,
	//BTCOM_PRINT_IGNORE,        // = 0xBC,
	BTCOM_SET_LED_SCREEN,      // = 0xA6,
	BTCOM_SET_FLAG_BIT,        // = 0xBC,
	BTCOM_WRITE_DEVICE_ID,     // = 0xBB,
	BTCOM_APP_IDENTITY,     	// = 0xD1,
	BTCOM_SEND_GRAY_DATA_ZIP,	// = 0xCF,
	BTCOM_SET_DENSITY,         // = 0xF2,
};
#endif
/**
 * 解析器初始化
 *
 */
	unsigned char* btCmdBuf = NULL;
	int ATCmdNum = 0;
	
	void btcomParserInit(u8 cmdData[],u8 cmdNum)
	{
		int i, j;
		u8 min_cmd;
		//deg_Printf("the num == %d\n",cmdNum);
		if(btCmdBuf == NULL){
			btCmdBuf = (u8*)hal_sysMemMalloc(cmdNum,64);
		}
	
		for (i = 0; i < cmdNum - 1; i++) {
			min_cmd = i;
			for (j = i + 1; j < cmdNum; j++) {
				if (cmdData[j] < cmdData[min_cmd]) {
					min_cmd = j;
				}
			}
			if (min_cmd != i) {
				u8 tmp;
				tmp = cmdData[min_cmd];
				cmdData[min_cmd] = cmdData[i];
				cmdData[i] = tmp;
			}
			
		}
		for (i = 0; i <cmdNum - 1; i++){	
			btCmdBuf[i] = cmdData[i];
			//deg_Printf("the btCmdBuf[%d]== %x\n",i,btCmdBuf[i]);
		}
		ATCmdNum = cmdNum;
	}
	
	void btcomParserUnInit(void)
	{
		if(btCmdBuf){
			hal_sysMemFree(btCmdBuf);	
			btCmdBuf = NULL;
		}
	
	}

/**
 * 判断是否支持给定命令
 *
 * cmd - 给定命令
 *
 * 返回:true - 支持；false - 不支持
 *
 */
bool btcomCmdSupport(u8 cmd)
{
	int begin, end, mid;
	bool ret = false;

	begin = 0;
	end = ATCmdNum - 1;
	while (begin <= end) {
		mid = (begin + end)>>1;
		if (btCmdBuf[mid] == cmd) {
			ret = true;
			break;
		} else if (btCmdBuf[mid] < cmd) {
			begin = mid + 1;
		} else {
			end = mid - 1;
		}
	}

	return ret;
}
#endif

/**
 * 计算checksum
 *
 * data - 要校验的数据
 * len - 数据长度
 * init_crc - crc初始值
 *
 * 返回:checksum
 *
 */
static const u8 CRC8_TAB[]={
    0x00,0x07,0x0E,0x09,0x1C,0x1B,0x12,0x15,0x38,0x3F,0x36,0x31,0x24,0x23,0x2A,0x2D,
    0x70,0x77,0x7E,0x79,0x6C,0x6B,0x62,0x65,0x48,0x4F,0x46,0x41,0x54,0x53,0x5A,0x5D,
    0xE0,0xE7,0xEE,0xE9,0xFC,0xFB,0xF2,0xF5,0xD8,0xDF,0xD6,0xD1,0xC4,0xC3,0xCA,0xCD,
    0x90,0x97,0x9E,0x99,0x8C,0x8B,0x82,0x85,0xA8,0xAF,0xA6,0xA1,0xB4,0xB3,0xBA,0xBD,
    0xC7,0xC0,0xC9,0xCE,0xDB,0xDC,0xD5,0xD2,0xFF,0xF8,0xF1,0xF6,0xE3,0xE4,0xED,0xEA,
    0xB7,0xB0,0xB9,0xBE,0xAB,0xAC,0xA5,0xA2,0x8F,0x88,0x81,0x86,0x93,0x94,0x9D,0x9A,
    0x27,0x20,0x29,0x2E,0x3B,0x3C,0x35,0x32,0x1F,0x18,0x11,0x16,0x03,0x04,0x0D,0x0A,
    0x57,0x50,0x59,0x5E,0x4B,0x4C,0x45,0x42,0x6F,0x68,0x61,0x66,0x73,0x74,0x7D,0x7A,
    0x89,0x8E,0x87,0x80,0x95,0x92,0x9B,0x9C,0xB1,0xB6,0xBF,0xB8,0xAD,0xAA,0xA3,0xA4,
    0xF9,0xFE,0xF7,0xF0,0xE5,0xE2,0xEB,0xEC,0xC1,0xC6,0xCF,0xC8,0xDD,0xDA,0xD3,0xD4,
    0x69,0x6E,0x67,0x60,0x75,0x72,0x7B,0x7C,0x51,0x56,0x5F,0x58,0x4D,0x4A,0x43,0x44,
    0x19,0x1E,0x17,0x10,0x05,0x02,0x0B,0x0C,0x21,0x26,0x2F,0x28,0x3D,0x3A,0x33,0x34,
    0x4E,0x49,0x40,0x47,0x52,0x55,0x5C,0x5B,0x76,0x71,0x78,0x7F,0x6A,0x6D,0x64,0x63,
    0x3E,0x39,0x30,0x37,0x22,0x25,0x2C,0x2B,0x06,0x01,0x08,0x0F,0x1A,0x1D,0x14,0x13,
    0xAE,0xA9,0xA0,0xA7,0xB2,0xB5,0xBC,0xBB,0x96,0x91,0x98,0x9F,0x8A,0x8D,0x84,0x83,
    0xDE,0xD9,0xD0,0xD7,0xC2,0xC5,0xCC,0xCB,0xE6,0xE1,0xE8,0xEF,0xFA,0xFD,0xF4,0xF3,
};
u8 btcomCheckSum(const u8 *data,int len,u8 init_crc)
{
	static u8 crc;
	crc=init_crc;
	int i;
	for(i=0;i<len;i++)
	{
		crc = CRC8_TAB[crc^data[i]];
		//deg_Printf("crc:0x%x 0x%x\n",crc,data[i]);
	}
	return crc;
}

